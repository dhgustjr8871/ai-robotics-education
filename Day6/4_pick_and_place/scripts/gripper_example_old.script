def unnamed():
  global _hidden_verificationVariable=0
  step_count_0b292c5d_a40f_47e1_98d0_56e246af0f2a = 0.0
  thread Step_Counter_Thread_b431ef9e_7259_4817_8d06_263f2c7e8e51():
    while (True):
      step_count_0b292c5d_a40f_47e1_98d0_56e246af0f2a = step_count_0b292c5d_a40f_47e1_98d0_56e246af0f2a + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_b431ef9e_7259_4817_8d06_263f2c7e8e51()
  set_gravity([0.0, 0.0, 9.82])
  #set_tcp(p[0.0,0.0,0.0,0.0,0.0,0.0])
  modbus_add_signal("192.167.0.1", 255, 400, 3, "MODBUS_1", False)
  modbus_set_signal_update_frequency("MODBUS_1", 10)
  modbus_add_signal("192.167.0.1", 255, 401, 3, "MODBUS_2", False)
  modbus_set_signal_update_frequency("MODBUS_2", 10)
  modbus_add_signal("192.167.0.1", 255, 402, 3, "MODBUS_3", False)
  modbus_set_signal_update_frequency("MODBUS_3", 10)
  modbus_add_signal("192.167.0.1", 255, 403, 3, "MODBUS_4", False)
  modbus_set_signal_update_frequency("MODBUS_4", 10)
  modbus_add_signal("192.167.0.1", 255, 404, 3, "MODBUS_5", False)
  modbus_set_signal_update_frequency("MODBUS_5", 10)
  modbus_add_signal("192.167.0.1", 255, 405, 3, "MODBUS_6", False)
  modbus_set_signal_update_frequency("MODBUS_6", 10)
  modbus_set_runstate_dependent_choice("MODBUS_1",0)
  modbus_set_runstate_dependent_choice("MODBUS_2",0)
  modbus_set_runstate_dependent_choice("MODBUS_3",0)
  modbus_set_runstate_dependent_choice("MODBUS_4",0)
  modbus_set_runstate_dependent_choice("MODBUS_5",0)
  modbus_set_runstate_dependent_choice("MODBUS_6",0)
  set_tool_communication(True, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(24)
  set_safety_mode_transition_hardness(1)
  set_target_payload(0.800000, [-0.001000, 0.030000, 0.047000], [0.001061, 0.001061, 0.001061, 0.000000, 0.000000, 0.000000])
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  # begin: URCap Installation Node
  #   Source: External Control, 1.0.5, FZI Research Center for Information Technology
  #   Type: External Control
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: OnRobot, 6.2.0, OnRobot A/S
  #   Type: OnRobot Setup
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 3.15.0.97830, Robotiq Inc.
  #   Type: Vacuum
 
  #######Vision urcap preamble start########
  
  logging_service = rpc_factory("xmlrpc","http://127.0.0.1:4747")
  # Converts a pose relative to the flange in the base frame.
  def get_T_in_base_from_flange(T_x_in_flange):
  
    T_flange_in_base = get_actual_tool_flange_pose()
  
    T_x_in_base = pose_trans(T_flange_in_base, T_x_in_flange)
  
    return T_x_in_base
  end
  
  # Search pose cartesian (camera pose)
  T_camera_in_flange = p[0.0, 0.05, 0.05, -0.5, 0.0, 0.0]
  snapshot_position_offset = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  ignore_snapshot_position = False
  canSaveImage = False
  
  # Open connection with vision service
  xmlrpc_server=rpc_factory("xmlrpc","http://127.0.0.1:4242")
  
  # Open connection with visual offset monitor
  cam_locate_monitor=rpc_factory("xmlrpc","http://127.0.0.1:33173")
  
  # Open connection with visual offset monitor
  visual_offset_monitor=rpc_factory("xmlrpc","http://127.0.0.1:42591")
  
  #######Vision urcap preamble end##########
  ###########################################
  
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 3.15.0.97830, Robotiq Inc.
  #   Type: Gripper
  RQ_UNIT_PERCENT = 0
  RQ_UNIT_MM = 1
  RQ_UNIT_INCH = 2
  
  global gripper_reconnecting = False
  rq_current_limit_enabled = False
  gripper_closed_norm = [100, 100, 100, 100]
  gripper_open_norm = [0, 0, 0, 0]
  gripper_closed_mm = [0, 0, 0, 0]
  gripper_open_mm = [50, 50, 50, 50]
  
  driver_gripper_client = rpc_factory("xmlrpc","http://localhost:63353")
  
  def rq_set_force_norm(force_norm, gripper_socket="1"):
      rq_wait_for_gripper_reconnection()
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      rq_set_force_norm_multi_grippers(force_norm, [slave_id])
  end
  
  def rq_set_force_norm_multi_grippers(force_norm, slave_ids=[9]):
      driver_gripper_client.setForce(slave_ids, force_norm)
  end
  
  def rq_set_speed_norm(speed_norm, gripper_socket="1"):
      rq_wait_for_gripper_reconnection()
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      rq_set_speed_norm_multi_grippers(speed_norm, [slave_id])
  end
  
  def rq_set_speed_norm_multi_grippers(speed_norm, slave_ids=[9]):
      driver_gripper_client.setSpeed(slave_ids, speed_norm)
  end
  
  def rq_open_and_wait(gripper_socket="1"):
      rq_wait_for_gripper_reconnection()
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      driver_gripper_client.openGripper(slave_id)
      rq_wait_for_motion_complete([slave_id])
  end
  
  def rq_close_and_wait(gripper_socket="1"):
      rq_wait_for_gripper_reconnection()
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      driver_gripper_client.closeGripper(slave_id)
      rq_wait_for_motion_complete([slave_id])
  end
  
  def rq_move_norm_multi_grippers(position, slave_ids=[9]):
     # rq_wait_for_gripper_reconnection fucntion is not called here because it is already done in the gripper contribution
     # script and this function is not defined for public usage.
     all_gripper_limits = get_all_gripper_limits(slave_ids)
     driver_gripper_client.move(slave_ids, position, RQ_UNIT_PERCENT, all_gripper_limits)
  end
  
  def rq_move_and_wait_norm_multi_grippers(position, slave_ids=[9]):
       all_gripper_limits = get_all_gripper_limits(slave_ids)
       driver_gripper_client.move(slave_ids, position, RQ_UNIT_PERCENT, all_gripper_limits)
       rq_wait_for_motion_complete(slave_ids)
  end
  
  def rq_move_and_wait(position, unit, gripper_socket="1"):
     rq_wait_for_gripper_reconnection()
     slave_id = gripper_socket_to_slave_id(to_str(gripper_socket))
     all_gripper_limits = get_all_gripper_limits([slave_id])
     driver_gripper_client.move([slave_id], position, unit, all_gripper_limits)
     rq_wait_for_motion_complete([slave_id])
  end
  
  def rq_move_and_wait_norm(position, gripper_socket="1"):
      rq_move_and_wait(position, RQ_UNIT_PERCENT, gripper_socket)
  end
  
  def rq_move_and_wait_mm(position, gripper_socket="1"):
      rq_move_and_wait(position, RQ_UNIT_MM, gripper_socket)
  end
  
  def rq_move_and_wait_inches(position, gripper_socket="1"):
     rq_move_and_wait(position, RQ_UNIT_INCH, gripper_socket)
  end
  
  def rq_is_object_detected(gripper_socket="1"):
     slave_id = gripper_socket_to_slave_id(gripper_socket)
     return driver_gripper_client.isObjectDetected(slave_id)
  end
  
  def rq_current_pos_norm(gripper_socket="1"):
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      gripper_limits = get_gripper_limits(gripper_socket)
      return driver_gripper_client.getCurrentPosition(slave_id,
                                    RQ_UNIT_PERCENT,
                                    gripper_limits[0],
                                    gripper_limits[1],
                                    gripper_limits[2],
                                    gripper_limits[3])
  end
  
  def rq_current_pos_mm(gripper_socket=1):
      slave_id = gripper_socket_to_slave_id(to_str(gripper_socket))
      gripper_limits = get_gripper_limits(to_str(gripper_socket))
      return driver_gripper_client.getCurrentPosition(slave_id,
                                    RQ_UNIT_MM,
                                    gripper_limits[0],
                                    gripper_limits[1],
                                    gripper_limits[2],
                                    gripper_limits[3])
  end
  
  def rq_current_pos_inches(gripper_socket=1):
      slave_id = gripper_socket_to_slave_id(to_str(gripper_socket))
      gripper_limits = get_gripper_limits(to_str(gripper_socket))
      return driver_gripper_client.getCurrentPosition(slave_id,
                                    RQ_UNIT_INCH,
                                    gripper_limits[0],
                                    gripper_limits[1],
                                    gripper_limits[2],
                                    gripper_limits[3])
  end
  
  def rq_reset(gripper_socket="1"):
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      driver_gripper_client.deactivate([slave_id])
  end
  
  def rq_set_gripper_max_cur(current_mA, gripper_socket="1"):
      rq_wait_for_gripper_reconnection()
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      driver_gripper_client.setMaximumCurrent(current_mA, slave_id)
  end
  
  def rq_get_gripper_max_cur(gripper_socket="1"):
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      return driver_gripper_client.getMaximumCurrent(slave_id)
  end
  
  def rq_set_max_current_for_all_grippers():
      rq_wait_for_gripper_reconnection()
      driver_gripper_client.setMaximumCurrentOnAllGrippers(rq_current_limit_enabled)
  end
  
  def rq_is_gripper_activated(slave_id=9):
      return driver_gripper_client.isGripperActivated(slave_id)
  end
  
  def rq_is_gripper_connected(slave_id=9):
      return driver_gripper_client.isGripperConnected(slave_id)
  end
  
  def rq_get_fault(slave_id=9):
      return driver_gripper_client.getFault(slave_id)
  end
  
  def rq_activate_and_wait(gripper_socket="1"):
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      if (not rq_is_gripper_activated(slave_id)):
        driver_gripper_client.activate([slave_id])
      end
  end
  
  def rq_activate_all_grippers(reset=False):
      empty_array_used_to_act_on_all_grippers = []
      if (reset):
        driver_gripper_client.deactivate(empty_array_used_to_act_on_all_grippers)
        driver_gripper_client.activate(empty_array_used_to_act_on_all_grippers)
      else:
        driver_gripper_client.activateIfRequired(empty_array_used_to_act_on_all_grippers)
      end
  end
  
  def get_closed_norm(gripper_socket):
      return gripper_closed_norm[rq_gripper_socket_to_index(gripper_socket)]
  end
  
  def get_open_norm(gripper_socket):
      return gripper_open_norm[rq_gripper_socket_to_index(gripper_socket)]
  end
  
  def get_open_mm(gripper_socket):
      return gripper_open_mm[rq_gripper_socket_to_index(gripper_socket)]
  end
  
  def get_closed_mm(gripper_socket):
      return gripper_closed_mm[rq_gripper_socket_to_index(gripper_socket)]
  end
  
  def set_closed_norm(closed_norm, gripper_socket):
      gripper_closed_norm[rq_gripper_socket_to_index(gripper_socket)] = closed_norm
  end
  
  def set_open_norm(open_norm, gripper_socket):
      gripper_open_norm[rq_gripper_socket_to_index(gripper_socket)] = open_norm
  end
  
  def set_closed_mm(closed_mm, gripper_socket):
      gripper_closed_mm[rq_gripper_socket_to_index(gripper_socket)] = closed_mm
  end
  
  def set_open_mm(opened_mm, gripper_socket):
      gripper_open_mm[rq_gripper_socket_to_index(gripper_socket)] = opened_mm
  end
  
  def slave_id_to_gripper_socket(slave_id):
      if slave_id == 9:
          return "1"
      else:
          return to_str(slave_id)
      end
  end
  
  def gripper_socket_to_slave_id(gripper_socket):
      if gripper_socket == "1":
          return 9
      else:
          return to_num(gripper_socket)
      end
  end
  
  def rq_slave_id_to_index(slave_id):
      if slave_id == 9:
          return 0
      else:
          return slave_id - 1
      end
  end
  
  def rq_gripper_socket_to_index(gripper_socket):
      return to_num(gripper_socket) - 1
  end
  
  def get_all_gripper_limits(slave_ids):
     all_gripper_limits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
     nb_slave_ids = get_list_length(slave_ids)
     slave_id_index = 0
     index = 0
     sub_index = 0
     while (index < nb_slave_ids):
         slave_id_index = 0
         items_per_limit = 4
         gripper_socket = slave_id_to_gripper_socket(slave_ids[index])
         gripper_limits = get_gripper_limits(gripper_socket)
         while (sub_index < items_per_limit):
            all_gripper_limits[index] = gripper_limits[sub_index]
            sub_index = sub_index + 1
            index = index + 1
         end
         index = index + 1
     end
  
     return all_gripper_limits
  end
  
  def get_gripper_limits(gripper_socket):
      return [get_closed_norm(gripper_socket),
              get_open_norm(gripper_socket),
              get_closed_mm(gripper_socket),
              get_open_mm(gripper_socket)]
  end
  
  def rq_wait_for_motion_complete(slave_ids):
      nb_slave_ids = get_list_length(slave_ids)
      index = 0
      while (index < nb_slave_ids):
        rq_wait(slave_ids[index])
        index = index + 1
      end
  end
  
  def rq_stop(gripper_socket="1"):
      slave_id = gripper_socket_to_slave_id(gripper_socket)
      driver_gripper_client.goto(slave_id, 0)
  end
  
  def rq_wait(slave_id):
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(slave_id)):
          # The following patch is for Robotiq's Camera issue when communication is lost, but not the activation
          # the communication driver reset the GTO bit
          driver_gripper_client.goto(slave_id, 1)
          sleep(0.1)
      end
  end
  
  def rq_is_motion_complete(slave_id):
      detection_flag = driver_gripper_client.getObjectDetectionFlag(slave_id)
      return detection_flag > 0 and detection_flag < 4
  end
  
  def write_error_popup(index, message_part_1, message_part_2, title):
      popup_message_part_1 = str_cat(message_part_1, index)
      popup_message_part_2 = str_cat(popup_message_part_1, " ")
      popup_message = str_cat(popup_message_part_2, message_part_2)
      return popup(popup_message, title, False, True, True)
  end
  
  def rq_disconnect_grippers():
      driver_gripper_client.pauseAndDisconnect()
  end
  
  def rq_reconnect_grippers(blocking=False, slave_ids=[]):
      if blocking:
          global gripper_reconnecting = True
          driver_gripper_client.reconnectAndResume(slave_ids)
          gripper_reconnecting = False
      else:
          thread recon_thread():
              rq_reconnect_grippers(True)
              return False
          end
          thrd = run recon_thread()
      end
  end
  
  def rq_wait_for_gripper_reconnection(timeout_s = 30.0):
      while (gripper_reconnecting == True):
          if (timeout_s <= 0):
            popup("Gripper has not reconnected before the expected time")
            halt
          else:
            sync()
            timeout_s = timeout_s - get_steptime()
          end
      end
  end
  set_closed_norm(100.0, "1")
  set_open_norm(0.0, "1")
  set_closed_mm(0.0, "1")
  set_open_mm(50.0, "1")
  set_closed_norm(100.0, "2")
  set_open_norm(0.0, "2")
  set_closed_mm(0.0, "2")
  set_open_mm(50.0, "2")
  set_closed_norm(100.0, "3")
  set_open_norm(0.0, "3")
  set_closed_mm(0.0, "3")
  set_open_mm(50.0, "3")
  set_closed_norm(100.0, "4")
  set_open_norm(0.0, "4")
  set_closed_mm(0.0, "4")
  set_open_mm(50.0, "4")
  rq_current_limit_enabled = False
  # end: URCap Installation Node
  rep_cnt = 0
  while (rep_cnt < 5):
    rep_cnt = rep_cnt + 1
    $ 2 "Robot Program"
    # begin: URCap Program Node
    #   Source: Robotiq_Grippers, 3.15.0.97830, Robotiq Inc.
    #   Type: Gripper
    $ 3 "Gripper Move50% (1)"
    gripper_slave_ids_0 = [9]
    popupErrorGripperWord = "Gripper"
    popupErrorNoConnection1 = "must be connected to run this program."
    popupErrorNoConnection2 = "No connection"
    popupErrorNotActivated1 = "is not activated. Go to Installation tab > Gripper to activate it and run the program again."
    popupErrorNotActivated2 = "Not activated"
    rq_gripper_speed = 60.0
    rq_gripper_force = 80.0
    rq_gripper_position = 49.80392156862745
    rq_is_blocking = True
    rq_is_robot_compliant = False
    nb_slave_ids = get_list_length(gripper_slave_ids_0)
    rq_wait_for_gripper_reconnection()
    index = 0
    while (index < nb_slave_ids):
        if (not rq_is_gripper_connected(gripper_slave_ids_0[index])):
            write_error_popup(index, popupErrorGripperWord, popupErrorNoConnection1, popupErrorNoConnection2)
        end
        index = index + 1
    end
    index = 0
    while (index < nb_slave_ids):
        if (not rq_is_gripper_activated(gripper_slave_ids_0[index])):
            write_error_popup(index, popupErrorGripperWord, popupErrorNotActivated1, popupErrorNotActivated2)
        end
        index = index + 1
    end
    rq_set_speed_norm_multi_grippers(rq_gripper_speed, gripper_slave_ids_0)
    rq_set_force_norm_multi_grippers(rq_gripper_force, gripper_slave_ids_0)
    if (rq_is_blocking):
        if rq_is_robot_compliant:
            zero_ftsensor()
            sleep(0.02)
            # Maximum allowed deviation values for non-compliant axes are default values generated by UR in a Force node
            force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
        end
        rq_move_and_wait_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_0)
        if rq_is_robot_compliant:
            end_force_mode()
        end
    else:
        rq_move_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_0)
    end
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: Robotiq_Grippers, 3.15.0.97830, Robotiq Inc.
    #   Type: Gripper
    $ 4 "Gripper Open (1)"
    gripper_slave_ids_1 = [9]
    popupErrorGripperWord = "Gripper"
    popupErrorNoConnection1 = "must be connected to run this program."
    popupErrorNoConnection2 = "No connection"
    popupErrorNotActivated1 = "is not activated. Go to Installation tab > Gripper to activate it and run the program again."
    popupErrorNotActivated2 = "Not activated"
    rq_gripper_speed = 60.0
    rq_gripper_force = 80.0
    rq_gripper_position = 0.0
    rq_is_blocking = True
    rq_is_robot_compliant = False
    nb_slave_ids = get_list_length(gripper_slave_ids_1)
    rq_wait_for_gripper_reconnection()
    index = 0
    while (index < nb_slave_ids):
        if (not rq_is_gripper_connected(gripper_slave_ids_1[index])):
            write_error_popup(index, popupErrorGripperWord, popupErrorNoConnection1, popupErrorNoConnection2)
        end
        index = index + 1
    end
    index = 0
    while (index < nb_slave_ids):
        if (not rq_is_gripper_activated(gripper_slave_ids_1[index])):
            write_error_popup(index, popupErrorGripperWord, popupErrorNotActivated1, popupErrorNotActivated2)
        end
        index = index + 1
    end
    rq_set_speed_norm_multi_grippers(rq_gripper_speed, gripper_slave_ids_1)
    rq_set_force_norm_multi_grippers(rq_gripper_force, gripper_slave_ids_1)
    if (rq_is_blocking):
        if rq_is_robot_compliant:
            zero_ftsensor()
            sleep(0.02)
            # Maximum allowed deviation values for non-compliant axes are default values generated by UR in a Force node
            force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
        end
        rq_move_and_wait_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_1)
        if rq_is_robot_compliant:
            end_force_mode()
        end
    else:
        rq_move_norm_multi_grippers(rq_gripper_position, gripper_slave_ids_1)
    end
    # end: URCap Program Node
  end
end
